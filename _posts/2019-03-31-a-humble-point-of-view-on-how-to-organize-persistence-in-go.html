---
layout: post
title: A humble point of view on how to organize persistence in Go
tag:
- persistence
- golang
---

<p>Currently, I’m writing a Telegram Bot in Golang, which requires a persistence layer. Digging around I’ve found an interesting article by <a href="https://www.alexedwards.net/blog/organising-database-access">Alex Edwards</a>, he depicts three main methods to organize database access:</p><ul><li>Using global variables in the persistence package</li><li>Using a dependency injection-like mechanism to inject the *sql.DB variable</li><li>Define an interface to define a sort of DAO layer and implement it using a concrete struct that encapsulates the connection pool (the *sql.DB instance)</li></ul><p>The first approach is for a small project or a ‘quick-and-dirty’ prototyping without any encapsulation or environment enforcement. The second one, instead, expects to have all handlers in a single package wrapping all the handler&#39;s instances to a single structure (for example Env); this structure has all the public methods for the handlers package. The third method, in my humble opinion, is the best one; defining an interface (or more than one depending on the organization of the tables) that hides the database access and enables all the possible tuning, this method is also useful (as explained in the article) to define a mock model for other package testing without the necessity to have a database instance on the CI/CD environment. Each interface implementation has its instance of*sql.DB (aka the connection pool). There is also a fourth method that enables to spread around the connection pool using the <a href="https://golang.org/pkg/context/">context</a> package, but (as the author) I&#39;m not a big fan of using application context for internal objects instead of &quot;business&quot; variables.</p><h3>A small improvement to interface model</h3><p>The *sql.DB is thread-safe by design, having a sync.Mutex field in the struct.</p><pre>type DB struct {<br>  ...<br> mu           sync.Mutex<br>  ...<br>}</pre><p>Which protects and regulates the access to the connection pool. During a “brainstorm” conversation with a <a href="https://twitter.com/mcilloni">co-worker</a>, we thought to separate the connection pool from the interface implementation using a channel of function as intermediate; and then run all received functions in a goroutine because of the thread safety of *sql.DB package. <br> How it extend the interface method? We assumed to have a persistence package where the developer should put all the logic regarding database interaction, so for each database entity, the developer could define an interface to &quot;interact&quot; with it. I will use the data structures and functions defined in Alex&#39;s blog post.</p><pre>type Book struct {<br>    Isbn   string<br>    Title  string<br>    Author string<br>    Price  float32<br>}<br><br>type BooksPersistor interface {<br>    AllBooks() ([]*Book, error)<br>}</pre><p>Now we will define the function that handles the database interaction.</p><pre>var dbhandlerChan = make(chan func(db *sql.DB))<br><br>func startHandler(db *sql.DB){<br>  for dbfunction := range dbchan {<br>    go dbfunction(handler)<br>  }<br>}</pre><p>Then we will implement the BookPersistor interface for Postgresql.</p><pre>type postgresBookPersistor struct {<br>  // store private variables if needed<br>}<br><br>func (persistor *postgresBookPersistor) awaitAndReturn(resChan chan []*Book, errChan chan error) ([]*Book, error){<br>  select{<br>    case books :=&lt;-resChan:<br>      return books, nil<br>    case err :=&lt;- errChan:<br>      return nil, err<br>  }<br>}<br><br>func (persistor *postgresBookPersistor) AllBooks() ([]*Book, error){<br>  booksChan := make(chan []*Books)<br>  errChan := make(chan error)<br>  defer close(booksChan)<br>  defer close(errChan)<br>  dbFunc := func(db *sql.DB){<br>    rows, err := db.Query(&quot;SELECT * FROM books&quot;)<br>    if err != nil {<br>        return nil, err<br>    }<br>    defer rows.Close()<br><br>    bks := make([]*Book, 0)<br>    for rows.Next() {<br>        bk := new(Book)<br>        err := rows.Scan(&amp;bk.Isbn, &amp;bk.Title, &amp;bk.Author, &amp;bk.Price)<br>        if err != nil {<br>            return nil, err<br>        }<br>        bks = append(bks, bk)<br>    }<br>    if err = rows.Err(); err != nil {<br>        return nil, err<br>    }<br>    return bks, nil<br>  }<br>  return persistor.awaitAndReturn(booksChan,errChan)<br>}</pre><p>We have also to implement a method for instantiating the “Postgres part” of the persistence module:</p><pre>func initPostgres() BookPersistor{<br>  db, err := sql.Open(&quot;postgres&quot;, dataSourceName) //NOTE the datasource could be obtained using viper, env variables or whatever<br>  if err != nil {<br>    panic(err)<br>  }<br>  go startHandler(db)<br>  return postgresBookPersistor{}<br>}</pre><p>Then to instantiate the persistence module you can have a StartPersistence(dbtype string) method which instantiates the interfaces for the correct db.</p><pre>func StartPersistence(driver string) (books BooksPersistor, err error){<br>  switch driver {<br>  case &quot;postgres&quot;:<br>    books = initPostgres()<br>  default:<br>    err = errors.New(&quot;Invalid driver&quot;)<br>  }<br>  return<br>}</pre><p>This “model” enables a more “organized” way to define your persistence module, enabling also seamless multi-db support. This is an initial proposal to an extended model for persistence in go. Please leave a comment, I’m curious about your opinion.</p><p><em>Originally published at </em><a href="https://www.carlomaiorano.me/golang/2019/03/31/golang-persistence.html"><em>https://www.carlomaiorano.me</em></a><em> on March 31, 2019.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=36260a4a2c9d" width="1" height="1" alt="">
