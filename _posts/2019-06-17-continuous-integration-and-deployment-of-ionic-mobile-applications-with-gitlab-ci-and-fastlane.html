---
layout: post
title: Continuous Integration and Deployment of Ionic mobile applications with Gitlab
  CI and Fastlane
tag:
- fastlane
- ionic
- ios
- android
- gitlab
---

<h3>Continuous Integration/Deployment for mobile</h3><p>Mobile software development (aka Apps Development) became more and more specific in this period, as far as becoming an entire department with (sometimes) hierarchy and open positions. This brought the need for common software development practices like Continuous Integration and Continuous Deployment.</p><p>The continuous integration is pretty standard with tests for the “business logic” and many others, like end-to-end tests with a simulated backend and so on and so forth. The continuous deployment, instead, consists of the distribution of an update through all the platform (iOS, Android, and sometimes Windows) stores.</p><p>So far everything seems a standard procedure, but among the jungle of mobile development frameworks (ionic, flutter, native development) is not! If the test part could be easily made using one of the test frameworks for the selected platform (in combination with the development framework), btw good luck with that, the deployment part requires some manual procedures and validation triggers.<br> Also to deploy in “production” applications you have to produce a lot of legal documentation (GDPR), and beyond that the developers have to produce screenshots of the application on a subset of devices. Fortunately, there is a tool that, beyond the legal stuff which is on the company/developer&#39;s own, there is a tool which covers all the distribution parts including screenshots (from the latest releases): Fastlane.</p><h3>Fastlane: quick and clean</h3><p><a href="https://fastlane.tools/">Fastlane</a> is a build tool for the fast release of the application, which covers also all the side aspects of the application publishing lifecycle and test running (only for apps written with the native SDK).<br> Fastlane could build your application using traditional build methods, like traditional build method for Android spawning a Gradle daemon or using xcodebuild for iOS, but it also supports cross-development platforms like React Native and Flutter; it supports also Ionic (fortunately!) using third-party plugins.<br> It could also, with some integrations in terms of software, perform other tasks like screenshots, beta (and also alpha for Android) deployment, and automatic code signing for iOS.</p><h3>Get Started with Fastlane</h3><p>Fastlane requires that you have already created the project(s) for your app on the stores, to do that there are a lot of articles, personally I suggest the one from <a href="https://themanifest.com/app-developmenthow-publish-app-google-play-step-step-guide">the manifest</a> for Android and a Medium article from the <a href="https://medium.com/@the_manifest/how-to-publish-your-app-on-apples-app-store-in-2018-f76f22a5c33a">same author</a> for iOS.<br> Then after the setup (assuming that you have already installed fastlane) you can move into your app directory ( cd &lt;your-app-directory&gt;) and then run fastlane init; once done you have a file called Fastfile where you can set your lanes and another file called Appfile. The Appfile contains all your credentials for your app deployment, like keystore (with password), or Apple Store ID for automatic code sign and upload; of course, the developer must set the environment, using the guides for <a href="https://docs.fastlane.tools/getting-started/ios/setup/">iOS</a> and <a href="https://docs.fastlane.tools/getting-started/android/setup/">Android</a>.<br> The Fastfile contains all the lane definitions for the application, they could be &quot;specialized&quot; for each platform (in case of cross-platforms). Each lane contains a set of actions, the developer could choose between the native and the one introduced by <a href="https://www.carlomaiorano.me/gitlab/2019/06/17/plugin">plugins</a>; for instance:</p><pre>lane :playstore do<br>  gradle(<br>    task: &#39;assemble&#39;,<br>    build_type: &#39;Release&#39;<br>  )<br>  upload_to_play_store # Uploads the APK built in the gradle step above and releases it to all production users<br>end</pre><p>this lane will build your Android application and, if everything goes fine, upload the APK to Play Store “in production” (where production means the release branch of the store).</p><h3>Fastlane features</h3><p>Fastlane supports side tasks in mobile app distribution like screenshots for <a href="https://docs.fastlane.tools/getting-started/ios/screenshots/">iOS</a> and <a href="https://docs.fastlane.tools/getting-started/android/screenshots/">Android</a>, leveraging on emulators for both platforms and other third-party software, this procedure could be automated in the FastFile using specific actions.</p><pre>lane :screenshots do<br>  capture_screenshots<br>  upload_to_app_store<br>end</pre><p>For iOS is pretty straightforward because everything is integrated with the development platform, on Android is different, see the <a href="https://docs.fastlane.tools/getting-started/android/screenshots/">guide</a>.</p><pre>lane :screenshots do<br>  capture_android_screenshots<br>  upload_to_play_store<br>end</pre><p>The Android screenshots part is required screengrab to take screenshots from the mobile emulator.<br> Fastlane originally was designed to support the entire lifecycle of native-developed mobile applications, in fact, the developer could also run tests.</p><pre>lane :tests do<br>  gradle(task: &quot;test&quot;)<br>end</pre><p>The above lane shows how to run tests on Android, for iOS, instead, it relies on a custom action because the build process is sliced in different tools.</p><pre>lane :tests do<br>  run_tests(workspace: &quot;Example.xcworkspace&quot;,<br>            devices: [&quot;iPhone 6s&quot;, &quot;iPad Air&quot;],<br>            scheme: &quot;MyAppTests&quot;)<br>end</pre><p>When hybrid/cross-development platforms began to become popular, and also to support integration with other horizontal platforms for developers (like slack, Hipchat, and so on) the Fastlane developers defined a plugin system. Each plugin defines custom actions, for instance, you can send a message to a Slack channel, to support other platforms or systems.<br> For instance with the gmail plugin the developer could send a short report using gmail, but there are tons of plugins to upload files to Slack, handle Firebase, handle version numbers and so on and so forth.</p><h3>Hybrid platforms</h3><p>Although Fastlane has a huge support to native development, it could handle also a wide variety of hybrid platforms. Platforms like Flutter and React Native are supported using the normal build process, more details <a href="https://flutter.dev/docs/deployment/fastlane-cd">here</a> for Flutter and <a href="https://carloscuesta.me/blog/shipping-react-native-apps-with-fastlane/">here</a> for React Native, Xamarin and Ionic/Cordova, instead, are supported through <a href="https://docs.fastlane.tools/plugins/available-plugins/">plugins</a> ( ionic and xamarin).</p><h3>GitLab CI for mobile applications</h3><p><a href="https://www.google.com/search?q=gitlab+ci&amp;oq=gitlab+ci&amp;aqs=chrome..69i57j69i60l5.2173j0j4&amp;sourceid=chrome&amp;ie=UTF-8">Gitlab CI</a> is an embedded CI/CD pipeline tool, that leverages <a href="https://docs.gitlab.com/runner/">runners</a> to perform tasks. In order to define a proper pipeline the developer must include a file named .gitlab-ci.yml in the repository.<br> Runner allows to run:</p><ul><li>Multiple jobs concurrently.</li><li>Use multiple tokens with multiple servers (even per-project).</li><li>Limit the number of concurrent jobs per token. Each runner job can be run:</li><li>Locally.</li><li>Using Docker containers.</li><li>Using Docker containers and executing jobs over SSH.</li><li>Using Docker containers with autoscaling on different clouds and virtualization hypervisors.</li><li>Connecting to remote SSH server. The runner:</li><li>Is written in Go and distributed as a single binary without any other requirements.</li><li>Supports Bash, Windows Batch, and Windows PowerShell.</li><li>Works on GNU/Linux, macOS, and Windows (pretty much anywhere you can run Docker).</li><li>Allows customization of the job running environment.</li><li>Automatic configuration reloads without restart.</li><li>Easy to use setup with support for Docker, Docker-SSH, Parallels, or SSH running environments.</li><li>Enables caching of Docker containers.</li><li>Easy installation as a service for GNU/Linux, macOS, and Windows.</li><li>Embedded Prometheus metrics HTTP server.<br> (credits Gitlab Runner <a href="https://docs.gitlab.com/runner/#features">documentation</a>)</li></ul><p>The runner could be configured using the TOML file, see GitLab runner advanced configuration <a href="https://docs.gitlab.com/runner/configuration/advanced-configuration.html">here</a> for details, each runner could be registered multiple times with different providers; for instance, a runner on macOS could accept shell tasks (for mobile app build) and also docker build stuff, a windows runner could execute shell tasks and docker (for windows containers) build.</p><h3>GitLab CI files and instructions</h3><p>The CI pipeline must be defined using a <a href="https://docs.gitlab.com/ee/ci/yaml/">YAML configuration</a> file, which allows define jobs, prepare the environment, perform other steps after each job or at the end of the pipeline.<br> The developer could select which type of runner to use in the CI build, using keywords like image, services or even tags to give some &quot;hints&quot; to the Gitlab CI job scheduler; if there aren&#39;t any feasible runners the job will remain in pending state. The CI jobs could be triggered only for special branches, or for some references (or tags) could perform deployment tasks.<br> For instance, this is an example (taken from the GitLab <a href="https://about.gitlab.com/2018/10/24/setting-up-gitlab-ci-for-android-projects/">blog</a>) of a CI file for Android:</p><pre>image: openjdk:8-jdk<br><br>variables:<br>  ANDROID_COMPILE_SDK: &quot;28&quot;<br>  ANDROID_BUILD_TOOLS: &quot;28.0.2&quot;<br>  ANDROID_SDK_TOOLS:   &quot;4333796&quot;<br><br>before_script:<br>  - apt-get --quiet update --yes<br>  - apt-get --quiet install --yes wget tar unzip lib32stdc++6 lib32z1<br>  - wget --quiet --output-document=android-sdk.zip https://dl.google.com/android/repository/sdk-tools-linux-${ANDROID_SDK_TOOLS}.zip<br>  - unzip -d android-sdk-linux android-sdk.zip<br>  - echo y | android-sdk-linux/tools/bin/sdkmanager &quot;platforms;android-${ANDROID_COMPILE_SDK}&quot; &gt;/dev/null<br>  - echo y | android-sdk-linux/tools/bin/sdkmanager &quot;platform-tools&quot; &gt;/dev/null<br>  - echo y | android-sdk-linux/tools/bin/sdkmanager &quot;build-tools;${ANDROID_BUILD_TOOLS}&quot; &gt;/dev/null<br>  - export ANDROID_HOME=$PWD/android-sdk-linux<br>  - export PATH=$PATH:$PWD/android-sdk-linux/platform-tools/<br>  - chmod +x ./gradlew<br>  # temporarily disable checking for EPIPE error and use yes to accept all licenses<br>  - set +o pipefail<br>  - yes | android-sdk-linux/tools/bin/sdkmanager --licenses<br>  - set -o pipefail<br><br>stages:<br>  - build<br>  - test<br><br>lintDebug:<br>  stage: build<br>  script:<br>    - ./gradlew -Pci --console=plain :app:lintDebug -PbuildDir=lint<br><br>assembleDebug:<br>  stage: build<br>  script:<br>    - ./gradlew assembleDebug<br>  artifacts:<br>    paths:<br>    - app/build/outputs/<br><br>debugTests:<br>  stage: test<br>  script:<br>    - ./gradlew -Pci --console=plain :app:testDebug</pre><p>This CI defines two main stages, build and test, in the first one it will perform some lint tasks and then build for debugging purposes the application, the test stage instead is used to run tests. The before-script session will be performed before every job in order to prepare the environment. The entire build/test process will be performed in docker containers.</p><h3>Combine Fastlane and Gitlab: use case with Ionic</h3><p>Although, as discussed previously, Fastlane is mainly designed for native mobile app development it supports also third party frameworks like <a href="https://ionicframework.com/">Ionic</a> through its plugin mechanism; combined with Gitlab CI pipelines, the automation process will be very straightforward.<br> First of all the developer has to do the Fastlane setup process for all the platforms that he wants to support (Android and/or iOS) producing the Fastfile and the Appfile, personally, I prefer to group all the Fastlane-relative files in a single folder on the root of the application project; another step that has to be done before proceeding, or at least before the first release in production/beta/alpha round, is the merge of the AppFile for the credentials of Android and iOS. A simple example of a merged Appfile could be:</p><pre># Apple Account configuration<br>app_identifier(&quot;&lt;your-bundle-identifier&gt;&quot;) # The bundle identifier of your app<br>apple_id(&quot;&lt;your-apple-id&gt;&quot;) # Your Apple email address<br><br>itc_team_id(&quot;&lt;itc-team-id&gt;&quot;) # App Store Connect Team ID<br>team_id(&quot;&lt;team-id&gt;&quot;) # Developer Portal Team ID<br><br># Android account configuration<br>package_name(&quot;&lt;your-package-name&gt;&quot;) # e.g. com.krausefx.app<br># For more information about the Appfile, see:<br>#     https://docs.fastlane.tools/advanced/#appfile</pre><p>Then we could install the desired ionic plugin using fastlane add_plugin ionic, this will produce a PluginFile like this:</p><pre># Autogenerated by fastlane<br>#<br># Ensure this file is checked in to source control!<br><br>gem &#39;fastlane-plugin-ionic&#39;<br><br># Gems could be installed also from github/gitlab or different paths</pre><p>The Pluginfile must be checked into your SCM (in this case a Gitlab repository), so each developer can run fastlane install_plugin to install all the plugins used in the Fastfile.<br> Now we can define a Fastfile to define each step of the build and release project.</p><pre>platform :android do<br>  desc &quot;Build the Android stuff in order to check if everything is correct&quot;<br>  lane :build do<br>    ionic(platform: &#39;android&#39;, release: false, device: false)<br>  end<br><br>  desc &quot;Upload to alpha channel&quot;<br>  lane :alpha do<br>    current_dir=Dir.pwd<br>    ionic(platform: &#39;android&#39;, device: false, keystore_path: current_dir+&#39;/my-release-key.keystore&#39;, keystore_password: ENV[&#39;STORE_PASS&#39;], keystore_alias: &#39;&lt;your-key-alias&gt;&#39;)<br>    upload_to_play_store(track: &#39;alpha&#39;, json_key:current_dir+&#39;/api.json&#39;, apk: &#39;platforms/android/app/build/outputs/apk/release/app-release.apk&#39;)<br>  end<br><br>  desc &quot;Upload to beta channel&quot;<br>  lane :beta do<br>    current_dir=Dir.pwd<br>    ionic(platform: &#39;android&#39;, device: false, keystore_path: current_dir+&#39;/my-release-key.keystore&#39;, keystore_password: ENV[&#39;STORE_PASS&#39;], keystore_alias: &#39;&lt;your-key-alias&gt;&#39;)<br>    upload_to_play_store(track: &#39;beta&#39;, json_key:current_dir+&#39;/api.json&#39;, apk: &#39;platforms/android/app/build/outputs/apk/release/app-release.apk&#39;)<br>  end<br><br>  desc &quot;Deploy a new version to the Google Play&quot;<br>  lane :deploy do<br>    current_dir=Dir.pwd<br>    ionic(platform: &#39;android&#39;, device: false, keystore_path: current_dir+&#39;/my-release-key.keystore&#39;, keystore_password: ENV[&#39;STORE_PASS&#39;], keystore_alias: &#39;&lt;your-key-alias&gt;&#39;)<br>    upload_to_play_store(json_key:current_dir+&#39;/api.json&#39;, apk: &#39;platforms/android/app/build/outputs/apk/release/app-release.apk&#39;)<br>  end<br>end<br><br>platform :ios do<br><br>  desc &quot;Build iOS in order to check if everthing is fine&quot;<br>  lane :build do<br>    ionic(platform: &#39;ios&#39;, type: &#39;development&#39;, device: false, release: false)<br>  end<br><br>  desc &quot;Upload to testflight&quot;<br>  lane :beta do<br>    cert<br>    sigh<br>    ionic(platform: &#39;ios&#39;, device: false)<br>    ipa_path=gym(project:&#39;./platforms/ios/&lt;your-app-name&gt;.xcodeproj&#39;,codesigning_identity:&#39;&lt;Code-signin-identity&gt;&#39;)<br>    testflight(skip_waiting_for_build_processing: true, ipa: ipa_path)<br>  end<br><br>  desc &quot;Upload to production&quot;<br>  lane :deploy do<br>    cert<br>    sigh<br>    ionic(platform: &#39;ios&#39;, device: false)<br>    ipa_path=gym(project:&#39;./platforms/ios/&lt;your-app-name&gt;.xcodeproj&#39;,codesigning_identity:&#39;&lt;Code-signin-identity&gt;&#39;)<br>    deliver(ipa: ipa_path)<br>  end<br>end</pre><p>The above Fastfile define a release process for Android alpha, beta, and production stages, instead for iOS you can define just the TestFlight and release lanes. The above process could be easily integrated with also the screenshot part but the Ionic plugin does not allow running tests; to run tests you have to rely on other plugins for interaction with the shell and ionic cli to run them.<br> The integration with Gitlab CI is pretty easy, but to build and release the iOS version you have to register a gitlab-runner that runs on macOS (you can use a hosting service like <a href="https://xcloud.me/">xCloud</a>) and you can select it in the CI file using tags. The macOS runner must be configured to run shell tasks because there are not any macOS docker containers. This is my CI file for my Ionic Application:</p><pre>image: cmaiorano/ionic-builder<br><br>stages:<br>  - build<br>  - publish<br><br>cache: # Working with runner cache<br>  untracked: true<br>  key: &quot;$CI_PROJECT_ID&quot;<br>  paths:<br>    - node_modules/<br><br>build_android:<br>  stage: build<br>  before_script:<br>    - npm i<br>  script:<br>    - fastlane android build<br><br>build_ios:<br>  stage: build<br>  before_script:<br>    - npm i<br>    - fastlane install_plugins<br>  script:<br>    - fastlane ios build<br><br>beta_ios:<br>  stage: publish<br>  only:<br>    - develop<br>    - /^feature-.*$/<br>  before_script:<br>    - npm i<br>    - fastlane install_plugins<br>  script:<br>    - fastlane ios beta  <br>  tags:<br>    - macosx<br><br>alpha_android:<br>  stage: publish<br>  only:<br>    - /^feature-.*$/<br>  before_script:<br>    - npm i<br>  script:<br>    - fastlane android alpha<br><br><br>beta_android:<br>  stage: publish<br>  only:<br>    - develop<br>  before_script:<br>  - npm i<br>  script:<br>    - fastlane android beta<br><br>release_ios:<br>  stage: publish<br>  only:<br>    - master<br>  before_script:<br>  - npm i<br>  - fastlane install_plugins<br>  script:<br>    - fastlane ios deploy<br>  tags:<br>    - macosx<br><br>release_android:<br>  stage: publish<br>  only:<br>    - master<br>  before_script:<br>  - npm i<br>  script:<br>    - fastlane android deplo</pre><p>The image used for CI was developed to build an Android application using the Android SDK plus the ionic environment and Fastlane with the Ionic plugin. The above gitlab-ci file does not respect the Git-Flow idea but takes into account hybrid application development and distribution.</p><p><em>Originally published at </em><a href="https://www.carlomaiorano.me/gitlab/2019/06/17/mobile-app-ci.html"><em>https://www.carlomaiorano.me</em></a><em> on June 17, 2019.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b1bab8099955" width="1" height="1" alt="">
