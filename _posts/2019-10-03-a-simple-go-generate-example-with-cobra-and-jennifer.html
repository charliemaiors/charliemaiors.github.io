---
layout: post
title: A simple go-generate example with Cobra and Jennifer
tag:
- cobra
- golang
- generator
- jennifer
---

<p>Golang is the most used programming language in distributed and concurrent systems, it is mainly used to write services and command-line applications. Golang, like many other programming languages, is Turing complete, this means that the developer could write go code which writes (or traditionally defined as generate) go code. Typically this feature is not so much appreciated as might be, but under the hood is used by many tools like the compiler or the test runner; the last one, indeed, scans all the packages that have to be tested, generates a go program containing the test harness, compiles, and run it (source <a href="https://blog.golang.org/generate">Golang blog</a>).<br> There are a lot of tools that generate code, which generates the implementation of stringer interface (the String() method) passing through which generates the MarshalJson() and UnmarshalJson() methods for JSON de/serializations till which generate the parser for your language grammar.<br> These tools are CLI applications that take as parameters files, data types, and so on; typically these apps must be invoked using the CLI like normal executables and use pflags as params. Golang takes into account also an automatization process to generate the code using a comment go:generate &lt;your-generator-app&gt; &lt;params&gt; which will be parsed by the go generate command and invoked as a normal executable, so is normal that your executable must be in your PATH (typically in your GOPATH).<br> For instance, you may want to generate the String() method, which corresponds to the Stringer interface implementation, using a generator; in particular using the stringer generator. The developer could choose to do it manually using:</p><pre>cd $GOPATH/src/&lt;your-full-service-path&gt; # or cd &lt;your-app-path&gt; if you are using modules<br>stringer -type=&lt;your-type-that-needs-String&gt;</pre><p>Or it can be done automatically by adding a comment in the source file and a step in the compilation pipeline:</p><pre>//go:generate stringer -type=Whatever<br><br>type Whatever struct {<br>  What string<br>  Ever int<br>}</pre><p>Then add this step in your CI/CD pipeline (or simply do it automatically in the root folder of your project):</p><pre>go generate<br>go build -o whatever &lt;your-main-file&gt;.go</pre><h3>A simple introduction to <a href="http://github.com/spf13/cobra">Cobra</a></h3><p>Cobra is a standard de-facto for CLI applications developed in Golang, among the different projects that use Cobra we can find the <a href="https://kubernetes.io/">Kubernetes</a> CLI, and <a href="https://www.docker.com/">Docker</a>.<br> Cobra has also a practical CLI generator (which is written using Cobra itself) to define your project structure, it can be installed using go get -u github.com/spf13/cobra/cmd and then run cobra init &lt;project-name&gt;. <br> Cobra supports all the main features of a CLI application:</p><ul><li>Flags and pflags</li><li>Usage and flags documentation generation</li><li>Subcommands with relative documentation generation</li><li>A deep integration with <a href="https://github.com/spf13/viper">Viper</a> to handle configurations and binding with environment variables for flag substitution.</li></ul><p>Cobra, as far as I’ve tested, supports also Go <a href="https://blog.golang.org/using-go-modules">modules</a> in order to create a new CLI application outside the GOPATH.</p><h3>Jennifer: a pretty straightforward code generation library</h3><p><a href="https://github.com/dave/jennifer">Jennifer</a> is a simple library to generate code in Golang, it supports the definition of all AST structures:</p><ul><li>Functions</li><li>Multiples assignments</li><li>and so on…</li></ul><p>Also, it supports automatic imports (using the Qual() function) and is intrinsically integrated with CI/CD tools because of the compilation phase after the code generation, which could be a pre-test environment. For instance, the user can generate a new file with all imports like this (taken from Jennifer&#39;s documentation):</p><pre>f := NewFilePath(&quot;a.b/c&quot;)<br>f.Func().Id(&quot;init&quot;).Params().Block(<br> Qual(&quot;a.b/c&quot;, &quot;Foo&quot;).Call().Comment(&quot;Local package - name is omitted.&quot;),<br> Qual(&quot;d.e/f&quot;, &quot;Bar&quot;).Call().Comment(&quot;Import is automatically added.&quot;),<br> Qual(&quot;g.h/f&quot;, &quot;Baz&quot;).Call().Comment(&quot;Colliding package name is renamed.&quot;),<br>)<br>fmt.Printf(&quot;%#v&quot;, f)<br><br>// Output:<br>// package c<br>//<br>// import (<br>//  f &quot;d.e/f&quot;<br>//  f1 &quot;g.h/f&quot;<br>// )<br>//<br>// func init() {<br>//  Foo()    // Local package - name is omitted.<br>//  f.Bar()  // Import is automatically added.<br>//  f1.Baz() // Colliding package name is renamed.<br>// }</pre><h3>A practical example</h3><p>Personally, I’ve used Jennifer, with Cobra, for a project during my research career. I had to write a client (in Golang) for the <a href="https://shinobi.video/">Shinobi Platform</a> in order to interact with it using the APIs, in particular, shinobi offers a lot of configuration to connect a new IP camera to the system. I need to have a map with all the possible configurations to programmatically define a new camera via API.<br> The project starts with the configuration of the new camera enabling the user to define a new monitored host. The client needs a data structure to grab the correct combination of camera brand and desired stream, to expose a properly formatted list of camera streaming options. First of all, you have to clone the <a href="https://gitlab.com/Shinobi-Systems/cameraConnectionList">GitLab repo</a> of the camera connection list, then write a parser for the repo structure which is pretty straightforward (for instance <a href="https://gitlab.com/charliemaiors/shinobi-param-generator/tree/master/parser">here</a> you can find the first version of it).<br> Then you have to model, using the Jennifer generator library, your data structure and the related methods, for instance, we can define struct for the baseline:</p><pre>file := jen.NewFilePathName(dest, pkg) //define the destination file<br> file.Comment(&quot;This is a generated file for mapping shinobi params from param source, DO NOT EDIT!!!&quot;) //comment it!!!<br><br> file.Comment(&quot;Path represent a path with given default values if present&quot;)<br> file.Type().Id(&quot;Path&quot;).Struct( //Define your custom data structures<br>  jen.Id(&quot;IsSecure&quot;).Bool(),<br>  jen.Id(&quot;SubPath&quot;).String(),<br> )<br><br> file.Comment(&quot;//Codec represent a subset of paths for a given codec&quot;)<br> file.Type().Id(&quot;Codec&quot;).Struct(<br>  jen.Id(&quot;CodecType&quot;).String(),<br>  jen.Id(&quot;Paths&quot;).Index().Id(&quot;Path&quot;),<br> )<br><br> file.Comment(&quot;//Protocol is the structure which represent a particular IPCam with it&#39;s vendor, protocol, codec and relative subpath&quot;)<br> file.Type().Id(&quot;Protocol&quot;).Struct(<br>  jen.Id(&quot;Connection&quot;).String(),<br>  jen.Id(&quot;Models&quot;).Index().String(),<br>  jen.Id(&quot;Codecs&quot;).Id(&quot;[]Codec&quot;),<br> )<br><br> file.Var().Id(&quot;paramsMap&quot;).Op(&quot;=&quot;).Map(jen.String()).Id(&quot;[]Protocol&quot;).Values(generator.generateDict(params))</pre><p>Then you can also define your public and private functions:</p><pre>file.Comment(&quot;//TakeAllPathsForVendorWithProtocol takes vendor and protocol and select the possibles values from paramsMap&quot;)<br>file.Func().Id(&quot;TakeAllPathsForVendorWithProtocol&quot;).Params(jen.Id(&quot;vendor&quot;).String(), jen.Id(&quot;protocol&quot;).String()).Parens(jen.Id(&quot;Protocol&quot;).Op(&quot;,&quot;).Error()).Block(<br>jen.Id(&quot;protocolsForVendor&quot;).Op(&quot;:=&quot;).Id(&quot;paramsMap&quot;).Id(&quot;[vendor]&quot;),<br>jen.For(jen.Id(&quot;_&quot;).Op(&quot;,&quot;).Id(&quot;current&quot;).Op(&quot;:=&quot;).Range().Id(&quot;protocolsForVendor&quot;)).Block(<br> jen.If(jen.Id(&quot;current&quot;).Op(&quot;.&quot;).Id(&quot;Connection&quot;).Op(&quot;==&quot;).Id(&quot;protocol&quot;)).Block(<br>  jen.Return(jen.Id(&quot;current&quot;), jen.Nil()),<br> ),<br>),<br>jen.Return(jen.Id(&quot;Protocol{}&quot;), jen.Qual(&quot;errors&quot;, &quot;New&quot;).Call(jen.Lit(&quot;No protocol found&quot;))),<br>)<br><br>file.Comment(&quot;//TakeProtocolForModel takes vendor and model and select the correspondent protocol&quot;)<br>file.Func().Id(&quot;TakeProtocolForModel&quot;).Params(jen.Id(&quot;model&quot;).String(), jen.Id(&quot;vendor&quot;).String()).Parens(jen.Id(&quot;Protocol&quot;).Op(&quot;,&quot;).Error()).Block(<br>jen.Id(&quot;protocolsForVendor&quot;).Op(&quot;:=&quot;).Id(&quot;paramsMap&quot;).Id(&quot;[vendor]&quot;),<br>jen.For(jen.Id(&quot;_&quot;).Op(&quot;,&quot;).Id(&quot;protocol&quot;).Op(&quot;:=&quot;).Range().Id(&quot;protocolsForVendor&quot;)).Block(<br> jen.If(jen.Qual(pkg, &quot;containsModel&quot;).Call(jen.Id(&quot;protocol&quot;).Op(&quot;.&quot;).Id(&quot;Models&quot;), jen.Id(&quot;model&quot;))).Block(<br>  jen.Return(jen.Id(&quot;protocol&quot;), jen.Nil()),<br> ),<br>),<br>jen.Return(jen.Id(&quot;Protocol{}&quot;), jen.Qual(&quot;errors&quot;, &quot;New&quot;).Call(jen.Lit(&quot;No protocol found&quot;))),<br>)</pre><p>For the public part, and the following for the private part:</p><pre>file.Func().Id(&quot;containsModel&quot;).Params(jen.Id(&quot;models&quot;).Id(&quot;[]string&quot;),      jen.Id(&quot;model&quot;).String()).Bool().Block(<br>jen.For(jen.Id(&quot;_&quot;).Op(&quot;,&quot;).Id(&quot;mod&quot;).Op(&quot;:=&quot;).Range().Id(&quot;models&quot;).Block(<br> jen.If(jen.Id(&quot;mod&quot;).Op(&quot;==&quot;).Id(&quot;model&quot;).Block(<br>  jen.Return(jen.True()),<br> )),<br>)),<br>jen.Return(jen.False()),<br>)</pre><p>The full generator code is available <a href="https://gitlab.com/charliemaiors/shinobi-param-generator/tree/master/generator">here</a>.</p><p><em>Originally published at </em><a href="https://www.carlomaiorano.me/golang/2019/10/03/generating-code-golang.html"><em>https://www.carlomaiorano.me</em></a><em> on October 3, 2019.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6925899d7326" width="1" height="1" alt="">
