---
layout: post
title: My journey with Gitlab, from AIO Omnibus to HA
tag:
- git
- gitlab
- selfhost
- openstack
---

<p>When I was doing a research grant at the university we had a problem with SCM, we relied on an old SVN server with all the projects on it and we wanted to migrate to git. Among the different on-premise offers (like <a href="https://gogs.io/">Gogs</a>, <a href="https://it.atlassian.com/software/bitbucket/download">Bitbucket server</a>) we choose <a href="https://about.gitlab.com/">Gitlab</a> because was (and is) the best on-premise SCM solution (and IMHO is growing up quickly also on cloud, they are very active on GCP, see <a href="https://about.gitlab.com/2018/10/11/gitlab-com-stability-post-gcp-migration/">here</a> and <a href="https://about.gitlab.com/2017/03/02/why-we-are-not-leaving-the-cloud/">here</a> and many more articles from their <a href="https://about.gitlab.com/blog/">blog</a>). I had a spare bare metal machine, see <a href="https://www.carlomaiorano.me/gitlab/2019/05/29/optiplex">figure</a> where I could make all the experiments that I wanted.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/0*vKmtgIb0B7Yjas4X.jpg" /></figure><p>So I’ve decided to install the <a href="https://docs.gitlab.com/omnibus/">Omnibus</a> package on that machine (which was running <a href="https://about.gitlab.com/install/#ubuntu">Ubuntu</a> at the time), assign a public IP, and register to a custom domain that we own (also for experiments). The initial configuration (without any extra services) takes into account just the external URL, and spare configuration for HTTPS and email:</p><pre>external_url &#39;https://&lt;your-desidered-gitlab-domain&gt;&#39;<br>gitlab_rails[&#39;gitlab_email_enabled&#39;] = true<br>gitlab_rails[&#39;gitlab_email_from&#39;] = &#39;&lt;your-email-address&gt;&#39;<br>gitlab_rails[&#39;gitlab_email_display_name&#39;] = &#39;Gitlab&#39;<br>gitlab_rails[&#39;gitlab_email_reply_to&#39;] = &#39;&lt;your-email-address&gt;&#39;<br>nginx[&#39;enable&#39;] = true<br>nginx[&#39;redirect_http_to_https&#39;] = true<br>nginx[&#39;listen_https&#39;] = true<br>nginx[&#39;ssl_certificate&#39;] = &quot;&lt;your-cert&gt;&quot;<br>nginx[&#39;ssl_certificate_key&#39;] = &quot;&lt;your-cert-key&gt;&quot;</pre><p>My colleagues started also to use it, migrating projects from the old SVN to the new server.</p><p>I’ve started to appreciate also other “side” functionalities, like <a href="https://www.docker.com/">Docker</a> Registry and the pipeline engine for <a href="https://www.wikiwand.com/en/Continuous_integration">CI</a> with tons of documentation. The configuration of the Docker Registry was pretty straightforward:</p><pre>registry_external_url &#39;https://&lt;your-registry-external-url&gt;&#39; # This could be the same of the gitlab external url (with different port) or anoter subdomain (or event a different domain) according to your configuration on the DNS<br>gitlab_rails[&#39;registry_enabled&#39;] = true<br>registry[&#39;enable&#39;] = true<br>registry_nginx[&#39;enable&#39;] = true<br><br>registry_nginx[&#39;listen_port&#39;] = 5001<br>registry_nginx[&#39;listen_https&#39;] = true<br>registry_nginx[&#39;ssl_certificate&#39;] = &quot;&lt;your-cert&gt;&quot; # Obtained with letsencrypt<br>registry_nginx[&#39;ssl_certificate_key&#39;] = &quot;&lt;your-cert-key&gt;&quot; # Obtained with letsencrypt</pre><h3>Moving to Cloud</h3><p>After a while also my colleagues started using the GitLab instance, so we decided to migrate to our internal IaaS (Openstack) in order to have higher reliability compared to the <a href="https://www.carlomaiorano.me/gitlab/2019/05/29/optiplex">Optiplex</a>. The migration was pretty much straightforward, I’ve just re-installed the gitlab-omnibus package, then restored the latest backup, modified the gitlab-secrets.json file and everything was up and running (IMHO the migration was very easy). I&#39;ve also appreciated the backup mechanism, which relies on a <a href="https://docs.chef.io/cookbooks.html">Chef Cookbook</a>, for its maximum configurability; in fact, we decided to move our backups to the Openstack Object Storage (Swift), the backup mechanism relies on <a href="https://github.com/fog/fog-openstack">Fog library</a> and the configuration was not so easy, but after some tests, I&#39;ve found the square. For completeness, I will report our configuration (with redacted sensitive values):</p><pre>gitlab_rails[&#39;backup_keep_time&#39;] = 604800<br><br>gitlab_rails[&#39;backup_upload_connection&#39;] = {<br>   &#39;provider&#39; =&gt; &#39;Openstack&#39;,<br>   &#39;openstack_auth_url&#39; =&gt; &#39;http://keystonev3url:5000/v3&#39;,<br>   &#39;openstack_username&#39; =&gt; &#39;username&#39;,<br>   &#39;openstack_api_key&#39; =&gt;  &#39;password&#39;,<br>   &#39;openstack_project_name&#39; =&gt; &#39;tenant&#39;,<br>   &#39;openstack_domain_id&#39; =&gt;    &#39;target-domain&#39;<br>}<br>gitlab_rails[&#39;backup_upload_remote_directory&#39;] = &#39;swift-container-name&#39;<br>gitlab_rails[&#39;backup_multipart_chunk_size&#39;] = 1048576000</pre><p>After some tests with this configuration, we choose to rely as much as possible on the Object Storage, to maintain the instance with enough free space. So we configured also the <a href="https://docs.gitlab.com/ee/user/project/pipelines/job_artifacts.html">artifacts storage</a>, which also saves a copy of the pipeline job logs on it (but atm has some <a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/57733">problem</a>), and the <a href="https://git-lfs.github.com/">lfs</a>. The configuration is pretty much the same, except for some parameters like the Swift temporary URL key.</p><p>The artifact snippet is:</p><pre>gitlab_rails[&#39;artifacts_enabled&#39;] = true<br># gitlab_rails[&#39;artifacts_path&#39;] = &quot;/mnt/storage/artifacts&quot;<br>gitlab_rails[&#39;artifacts_object_store_enabled&#39;] = true # EE only<br>gitlab_rails[&#39;artifacts_object_store_remote_directory&#39;] = &quot;artifacts-container&quot;<br>gitlab_rails[&#39;artifacts_object_store_connection&#39;] = {<br>   &#39;provider&#39; =&gt; &#39;OpenStack&#39;,<br>   &#39;openstack_auth_url&#39; =&gt; &#39;http://keystonev3url:5000/v3&#39;,<br>   &#39;openstack_username&#39; =&gt; &#39;user&#39;,<br>   &#39;openstack_api_key&#39; =&gt;  &#39;password&#39;,<br>   &#39;openstack_project_name&#39; =&gt; &#39;project&#39;,<br>   &#39;openstack_domain_id&#39; =&gt;    &#39;domain&#39;,<br>   &#39;openstack_temp_url_key&#39; =&gt; &#39;swift-temp-url-key&#39;<br>}</pre><p>Instead the LFS configuration snippet:</p><pre>### Git LFS<br>gitlab_rails[&#39;lfs_enabled&#39;] = true<br># gitlab_rails[&#39;lfs_storage_path&#39;] = &quot;/mnt/storage/lfs-objects&quot;<br>gitlab_rails[&#39;lfs_object_store_enabled&#39;] = true # EE only<br>gitlab_rails[&#39;lfs_object_store_background_upload&#39;] = true # Our object storage is not so fast so we choose to do a background upload instead of have timeouts<br>gitlab_rails[&#39;lfs_object_store_remote_directory&#39;] = &quot;lfs-container&quot;<br>gitlab_rails[&#39;lfs_object_store_connection&#39;] = {<br>   &#39;provider&#39; =&gt; &#39;OpenStack&#39;,<br>   &#39;openstack_auth_url&#39; =&gt; &#39;http://keystonev3url:5000/v3&#39;,<br>   &#39;openstack_username&#39; =&gt; &#39;username&#39;,<br>   &#39;openstack_api_key&#39; =&gt; &#39;password&#39;,<br>   &#39;openstack_project_name&#39; =&gt; &#39;project&#39;,<br>   &#39;openstack_domain_id&#39; =&gt; &#39;domain&#39;,<br>   &#39;openstack_temp_url_key&#39; =&gt; &#39;swift-temp-url-key&#39;<br>}</pre><p>The Openstack cluster hosts (among all the projects) also other horizontal services that use databases, Vey-Value Store, and many other architectural components that can be shared between services. In particular, we had (btw they are still running) some services which rely on PostgreSQL as a database, so we decided to “clusterize” all the Postgres instances in order to have high availability and streamed data replication; from a functional point of view, I’ve deployed a set of PostgreSQL instances and migrated all other databases to the cluster in order to have the same version on the same OS. I’ve used Ansible (in this <a href="https://github.com/geerlingguy/ansible-role-postgresql">role</a>, I’ve used a lot of roles written by <a href="https://www.jeffgeerling.com/">Geerlingguy</a> because works as expected and covers all the aspects of the target service/application), to deploy Postgres and then performed some other manual tasks to create the cluster. Once deployed the cluster I started the migration of GitLab data to the external cluster (Note: the cluster is without pgbouncer), I’ve done these steps to move from the internal Postgres to the external one (assuming the external cluster is up and running):</p><ol><li>Dump the internal Database: sudo -u gitlab-psql /opt/gitlab/embedded/bin/pg_dumpall --username=gitlab-psql --host=/var/opt/gitlab/postgresql &gt; /var/lib/pgsql/database.sql</li><li>Import the dump into the cluster sudo -u postgres psql -f /var/lib/pgsql/database.sql (this is an example feel free to import it as you prefer)</li><li>Create the gitlab and set its password: sudo -u postgres psql -c &quot;ALTER USER gitlab ENCRYPTED PASSWORD &#39;password&#39; VALID UNTIL &#39;infinity&#39;;&quot;</li><li>Then modify the configuration file setting the following values:</li></ol><pre>postgresql[&#39;enable&#39;] = false # Disable the embedded PostgreSQL<br>gitlab_rails[&#39;db_adapter&#39;] = &quot;postgresql&quot;<br>gitlab_rails[&#39;db_encoding&#39;] = &quot;unicode&quot;<br>gitlab_rails[&#39;db_database&#39;] = &quot;gitlabhq_production&quot; # Is the default created in the embedded instance<br>gitlab_rails[&#39;db_username&#39;] = &quot;gitlab&quot;<br>gitlab_rails[&#39;db_password&#39;] = &quot;password&quot;<br>gitlab_rails[&#39;db_host&#39;] = &quot;&lt;cluster-master-ip-address&gt;&quot;<br>gitlab_rails[&#39;db_port&#39;] = 5432 # Tipically the 5432</pre><ol><li>Then reconfigure and restart (sudo gitlab-ctl reconfigure &amp;&amp; sudo gitlab-ctl restart)</li></ol><p>The migration to the external database was smooth, but a major update (11.9) caused a little outage; btw I opened an <a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/59455">issue</a> and the efficient Gitlab team supported us and in a few minutes Gitlab was up and running again.</p><h3>Scaling</h3><p>Then we decided to move our Gitlab deployment architecture from the AIO with Omnibus to the High Availability with the <a href="https://docs.gitlab.com/ee/administration/high_availability/README.html#horizontal">horizontal model</a>, like the one in <a href="https://www.carlomaiorano.me/gitlab/2019/05/29/horizontal">figure</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*T6BTbUixPoit3JXr.png" /></figure><p>To achieve this I’ve started with the deployment of a Redis (plus Sentinel, in particular, the number of Sentinels must be odd otherwise they will not reach consensus) cluster.</p><p>We deployed the Redis cluster using Ansible, in particular using the role provided by <a href="https://github.com/DavidWittman/ansible-redis">David Wittman</a>; then we configured the only omnibus installation to interact with the Redis Sentinels and the master of the cluster. In particular:</p><pre>gitlab_rails[&#39;redis_password&#39;] = &#39;&lt;redis-password&gt;&#39;<br>gitlab_rails[&#39;redis_sentinels&#39;] = [<br>  {&#39;host&#39; =&gt; &#39;&lt;host-1&gt;&#39;, &#39;port&#39; =&gt; 26379},<br>  {&#39;host&#39; =&gt; &#39;&lt;host-2&gt;&#39;, &#39;port&#39; =&gt; 26379},<br>  {&#39;host&#39; =&gt; &#39;&lt;host-3&gt;&#39;, &#39;port&#39; =&gt; 26379},<br>]<br>redis[&#39;enable&#39;] = false<br>redis[&#39;master_name&#39;] = &#39;&lt;redis-master-name&gt;&#39;</pre><p>Reading the documentation we found that each instance of the application server must have a NFS share where they can read and write files which becames from git operations (push, pull etc etc), our Openstack Cluster hadn’t the possibility to have a <a href="https://docs.openstack.org/cinder/latest/admin/blockstorage-volume-multiattach.html">multi-attach volume</a> so we decided to deploy a machine with only the <a href="https://docs.gitlab.com/ee/administration/gitaly/">Gitaly</a> service on it. The migration from the local storage to the Gitaly machine was smooth, we followed these steps:</p><ol><li>Deploy the machine with enough ram and an high number of vcpu to handle all the requests (for the moment), and a sufficiently big Cinder volume attached</li><li>Install Gitlab Omnibus on it, see <a href="https://about.gitlab.com/install/">here</a></li><li>Prepare the volume and add it to the fstab (like in this <a href="https://medium.com/@sh.tsang/partitioning-formatting-and-mounting-a-hard-drive-in-linux-ubuntu-18-04-324b7634d1e0">post</a>)</li><li>Configure the instance with ONLY these values:</li></ol><pre>gitlab_rails[&#39;internal_api_url&#39;] = &#39;https://&lt;your-gitlab-external-url&gt;&#39;<br>gitlab_rails[&#39;auto_migrate&#39;] = false<br>gitlab_rails[&#39;rake_cache_clear&#39;] = false<br>gitlab_workhorse[&#39;enable&#39;] = false<br>unicorn[&#39;enable&#39;] = false<br>sidekiq[&#39;enable&#39;] = false<br>postgresql[&#39;enable&#39;] = false<br>redis[&#39;enable&#39;] = false<br>nginx[&#39;enable&#39;] = false<br>prometheus[&#39;enable&#39;] = false<br>alertmanager[&#39;enable&#39;] = false<br>node_exporter[&#39;enable&#39;] = false<br>redis_exporter[&#39;enable&#39;] = false<br>pgbouncer_exporter[&#39;enable&#39;] = false<br>gitlab_monitor[&#39;enable&#39;] = false<br>gitaly[&#39;enable&#39;] = true<br>gitaly[&#39;listen_addr&#39;] = &quot;0.0.0.0:8075&quot; # This is the usual configuration for tcp WITHOUT tls (in our infrastructure gitaly is in a &quot;trust zone&quot;)<br>gitaly[&#39;auth_token&#39;] = &#39;&lt;your-supersecret-token&gt;&#39;<br>gitaly[&#39;storage&#39;] = [<br>   {<br>     &#39;name&#39; =&gt; &#39;default&#39;,<br>     &#39;path&#39; =&gt; &#39;&lt;your-path&gt;&#39;<br>   } # more than one storage repo could be defined<br>]</pre><p>Then you need to:</p><ol><li>Reconfigure and restart the gitlay instance: # gitlab-ctl reconfigure &amp;&amp; gitlab-ctl restart</li><li>Rsync the omnibus repository folder to the gitaly folder and set the proper permissions: rsync -qaHAXS -e ssh /var/opt/gitlab/git-data/ user@gitaly-server:/&lt;your-path&gt;</li><li>Modify the ominibus installation configuration in order to use the gitaly server:</li></ol><pre>gitlab_rails[&#39;gitaly_token&#39;] = &#39;&lt;your-supersecret-token&gt;&#39;<br>git_data_dirs({<br>&quot;default&quot; =&gt; {<br>  &quot;path&quot; =&gt; &quot;&lt;your-path&gt;&quot;,<br>  &quot;gitaly_address&quot; =&gt; &quot;tcp://&lt;gitaly-address&gt;:8075&quot;<br>}<br>})</pre><p>Reconfigure and restart the omnibus installation: # gitlab-ctl reconfigure &amp;&amp; gitlab-ctl restart</p><p>After Gitaly we deployed yall the side components to reach the horizontal scalability, the missing components are: the reverse proxy/load balancer, and at least another gitlab instance.</p><p>I’ve made it deploy another GitLab instance using nearly the same configuration, and together, I modified the configuration of a “Gateway” that we use for each service, which is an nginx with multiple hosts configured, one for each service.</p><p>The second Gitlab instance was configured taking as reference the HA <a href="https://docs.gitlab.com/ee/administration/high_availability/gitlab.html">documentation</a>, but instead of NFS, we rely on Gitaly so the storage configuration part was replicated using the one from Gitaly (see above). The only exception was the docker registry, this feature relies completely on NFS because the registry needs a storage folder and our Cinder deployment does not support the multi-attach property; so we decided not to have a complete “mirror” in functionalities between the two application servers exploiting the custom domain for the registry on the load balancer. The configuration of the second was the same as the first one except for the docker registry configuration and these parameters:</p><pre> gitlab_shell[&#39;secret_token&#39;] = &#39;&lt;your-secret-token&gt;&#39;<br> gitlab_rails[&#39;otp_key_base&#39;] = &#39;&lt;your-otp-key-base&gt;&#39;<br> gitlab_rails[&#39;secret_key_base&#39;] = &#39;&lt;your-secret-key-base&gt;&#39;<br> gitlab_rails[&#39;db_key_base&#39;] = &#39;&lt;your-db-key-base&gt;&#39;</pre><p>Also as explained in the <a href="https://docs.gitlab.com/ee/administration/high_availability/gitlab.html">guide</a>, we configured the instance to avoid the database migration on the new version:</p><pre># touch /etc/gitlab/skip-autoreconfigure</pre><p>We had also to modify both of the instances&#39; nginx configuration, in order to be aware of the reverse proxy. The gitlab_nginx final configuration is:</p><pre>nginx[&#39;real_ip_trusted_addresses&#39;] = [ &#39;&lt;load-balancer-ip&gt;&#39; ]<br>nginx[&#39;real_ip_header&#39;] = &#39;X-Forwarded-For&#39;<br>nginx[&#39;real_ip_recursive&#39;] = &#39;on&#39;<br>nginx[&#39;listen_https&#39;] = false<br>nginx[&#39;listen_port&#39;] = 80<br>#nginx[&#39;ssl_certificate&#39;] = &quot;&lt;cert&gt;&quot;<br>#nginx[&#39;ssl_certificate_key&#39;] = &quot;&lt;priv-key&gt;&quot;<br>#nginx[&#39;redirect_http_to_https&#39;] = true<br>nginx[&#39;proxy_set_headers&#39;] = {<br>  &quot;Host&quot; =&gt; &quot;$http_host_with_default&quot;,<br>  &quot;X-Real-IP&quot; =&gt; &quot;$remote_addr&quot;,<br>  &quot;X-Forwarded-For&quot; =&gt; &quot;$proxy_add_x_forwarded_for&quot;,<br>  &quot;X-Forwarded-Proto&quot; =&gt; &quot;https&quot;,<br>  &quot;X-Forwarded-Ssl&quot; =&gt; &quot;on&quot;,<br>  &quot;Upgrade&quot; =&gt; &quot;$http_upgrade&quot;,<br>  &quot;Connection&quot; =&gt; &quot;$connection_upgrade&quot;<br>}</pre><p>On the instance with the Docker registry, we have to modify the values relatives to the nginx instance which handle it. In particular, we had to remove the HTTPS and change the listening port.</p><pre>registry_nginx[&#39;enable&#39;] = true<br><br>registry_nginx[&#39;listen_port&#39;] = 5001<br>registry_nginx[&#39;listen_https&#39;] = false<br>registry_nginx[&#39;proxy_set_headers&#39;] = {<br>  &quot;Host&quot; =&gt; &quot;$http_host&quot;,<br>  &quot;X-Real-IP&quot; =&gt; &quot;$remote_addr&quot;,<br>  &quot;X-Forwarded-For&quot; =&gt; &quot;$proxy_add_x_forwarded_for&quot;,<br>  &quot;X-Forwarded-Proto&quot; =&gt; &quot;https&quot;,<br>  &quot;X-Forwarded-Ssl&quot; =&gt; &quot;on&quot;<br>}</pre><p>Then we moved to the load balancer to properly configure the vhosts of the registry and GitLab, and also the SSH access to GitLab. The load balancer is an instance of nginx configured to act as a reverse proxy/load balancer for some services. I will avoid the base configuration and report only the relevant files for each service.</p><p>The configuration for the application servers is:</p><pre>upstream gitlab {<br> server &lt;gitlab-instance-1&gt;;<br> server &lt;gitlab-instance-2&gt;;<br>}<br><br>server {<br> listen 80;<br> server_name &lt;gitlab.your-domain.your-gtld&gt;;<br> return 301 https://$server_name$request_uri;<br>}<br>server {<br> listen 443 ssl http2;<br> server_name &lt;gitlab.your-domain.your-gtld&gt;;<br> ssl_certificate &lt;your-cert&gt;;<br>   ssl_certificate_key &lt;your-key&gt;<br>   ssl_trusted_certificate &lt;your-trust-chain&gt;; # For some services which uses gitlab API<br>   ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>   ssl_ciphers &#39;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&#39;;<br>   ssl_prefer_server_ciphers on;<br>   ssl_dhparam &lt;your-dh-param&gt;;<br> server_tokens off;<br> ssl on;<br> add_header X-Content-Type-Options nosniff;<br><br> location / {<br>  gzip off;<br>    proxy_set_header Host $http_host;<br>    proxy_set_header X-Real-IP $remote_addr;<br>    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>    proxy_set_header X-Forwarded-Proto $scheme;<br>    proxy_set_header X-Forwarded-Protocol $scheme;<br>    proxy_set_header X-Url-Scheme $scheme;<br>  proxy_set_header X-Frame-Options     SAMEORIGIN;<br>  proxy_pass http://gitlab;<br> }<br><br>   location /profile/personal_access_tokens { <br>      gzip off;   <br>      proxy_set_header Host $http_host;<br>      proxy_set_header X-Real-IP $remote_addr;<br>      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>      proxy_set_header X-Forwarded-Proto $scheme;<br>      proxy_set_header X-Forwarded-Protocol $scheme;<br>      proxy_set_header X-Url-Scheme $scheme;<br>      proxy_set_header X-Frame-Options     SAMEORIGIN;<br>      proxy_pass http://&lt;gitlab-docker-registry-instance&gt;;<br>   }<br>}</pre><p>The last part of the configuration is necessary because in my deployment only one instance has the registry configured, so if the developer needs to generate a token to read or interact with the registry must be redirected to the correct instance. Also, the permissions of the instance with the docker registry are a superset of the other one.</p><p>Typically git relies on SSH/HTTP/HTTPS, the above configuration enables only HTTPS so I defined another load balancer rule on the gateway using the nginx<a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html"> stream module</a>, these kinds of rules must be defined (or <a href="http://nginx.org/en/docs/ngx_core_module.html#include">included</a>) outside of the HTTP section.</p><p>Finally, we defined the vhost for the Docker registry (because we chose a custom domain for it), which is a simple reverse proxy configuration that enables the proxy for the docker registry.</p><pre>server {<br> listen 80;<br> server_name &lt;your-registry-domain&gt;;<br> return 301 https://$server_name$request_uri;<br>}<br><br>server {<br> listen 443 ssl http2;<br> server_name &lt;your-registry-domain&gt;;<br> ssl_certificate &lt;your-cert&gt;;<br>   ssl_certificate_key &lt;your-key&gt;;<br>   ssl_trusted_certificate &lt;your-trust-chain&gt;;<br>   ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>   ssl_ciphers &#39;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&#39;;<br>   ssl_prefer_server_ciphers on;<br>   ssl_session_cache shared:SSL:10m;<br>   ssl_dhparam &lt;dh-param&gt;;<br>   add_header Strict-Transport-Security &quot;max-age=31536000; includeSubdomains;&quot;;<br><br> location / {<br>    proxy_set_header Host $http_host;<br>    proxy_set_header X-Real-IP $remote_addr;<br>    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>    proxy_set_header X-Forwarded-Proto $scheme;<br>    proxy_set_header X-Forwarded-Protocol $scheme;<br>    proxy_set_header X-Url-Scheme $scheme;<br>  proxy_pass http://docker-registry-ip:5001;<br> }<br>}</pre><p>I hope that this little narration plus some configuration snippets could be helpful. Enjoy :)</p><p><em>Originally published at </em><a href="https://www.carlomaiorano.me/gitlab/2019/05/29/from-omnibus-to-ha.html"><em>https://www.carlomaiorano.me</em></a><em> on May 29, 2019.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=35015ce50a88" width="1" height="1" alt="">
